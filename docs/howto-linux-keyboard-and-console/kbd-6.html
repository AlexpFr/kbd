<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
		<title>The Linux keyboard and console HOWTO: The console character sets</title>
	</head>
	<body class="container">
		<nav>
			<ul class="pager">
				<li class="previous"><a href="kbd-5.html">Previous</a></li>
				<li class="next"><a href="kbd-7.html">Next</a></li>
			</ul>
		</nav>

		<div class="page-header">
			<h2><a name="s6">The console character sets</a></h2>
		</div>

		<p>The kernel first tries to figure out what symbol is meant by any given
		user byte, and next where this symbol is located in the current font.</p>

		<p>The kernel knows about 5 translations of bytes into console-screen symbols.
		In Unicode (UTF-8) mode, the UTF-8 code is just converted directly into
		Unicode. The assumption is that almost all symbols one needs are present
		in Unicode, and for the cases where this does not hold the codes
		0xf000-0xf1ff are reserved for direct font access.
		When not in Unicode mode, one of four translation tables is used.
		The four tables are: a) Latin1 -&gt; Unicode,  b) VT100 graphics -&gt; Unicode,
		c) PC -&gt; Unicode, d) user-defined.</p>

		<p>There are two character sets, called G0 and G1, and one of them
		is the current character set. (Initially G0.)
		Typing Ctrl-N causes G1 to become current, Ctrl-O causes G0 to become current.</p>

		<p>These variables G0 and G1 point at a translation table, and can be changed
		by the user. Initially they point at tables a) and b), respectively.
		The sequences ESC ( B and ESC ( 0 and ESC ( U and ESC ( K cause G0 to point
		at translation table a), b), c) and d), respectively.
		The sequences ESC ) B and ESC ) 0 and ESC ) U and ESC ) K cause G1 to point
		at translation table a), b), c) and d), respectively.</p>

		<p>The sequence ESC c causes a terminal reset, which is what you want if the
		screen is all garbled. The oft-advised <code>echo ^V^O</code> will only
		make G0 current, but there is no guarantee that G0 points at table a).
		In some distributions there is a program reset(1) that just does
		<code>echo ^[c</code>.
		If your termcap entry for the console is correct (and has an entry
		<code>:rs=\Ec:</code>), then also <code>setterm -reset</code> will work.</p>

		<p>The user-defined mapping table can be set using mapscrn(8).
		The result of the mapping is that if a symbol c is printed, the symbol
		<code>s = map[c]</code> is sent to the video memory. The bitmap that corresponds to
		<code>s</code> is found in the character ROM, and can be changed using setfont(8).</p>

		<hr/>
		<nav>
			<ul class="pager">
				<li class="previous"><a href="kbd-5.html">Previous</a></li>
				<li class="next"><a href="kbd-7.html">Next</a></li>
			</ul>
		</nav>
	</body>
</html>
