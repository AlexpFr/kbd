<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
		<title>The Linux keyboard and console HOWTO: Unusual keys and keyboards</title>
	</head>
	<body class="container">
		<nav>
			<ul class="pagination">
				<li class="page-item"><a class="page-link" href="kbd-13.html">Previous</a></li>
				<li class="page-item"><a class="page-link" href="kbd-15.html">Next</a></li>
			</ul>
		</nav>

		<div class="page-header">
			<h2><a name="s14">Unusual keys and keyboards</a></h2>
		</div>

		<P>The two keys PrintScrn/SysRq and Pause/Break are special in that they
		have two keycodes: the former has keycode 84 when Alt is pressed
		simultaneously, and keycode 99 otherwise; the latter has keycode
		101 when Ctrl is pressed simultaneously, and keycode 119 otherwise.
		(Thus, it makes no sense to bind functions to Alt keycode 99 or
		Ctrl keycode 119.) The Pause/Break key is also special in another way:
		it does not generate key-up scancodes, but generates the entire
		6-scancode sequence on key-down.</p>

		<P>If you have strange keys, that do not generate any code under Linux
		(or generate messages like "unrecognized scancode"), and your kernel
		is 1.1.63 or later, then you can use setkeycodes(1) to tell the kernel
		about them. Once they have gotten a keycode from <code>setkeycodes</code>,
		they can be assigned a function by <code>loadkeys</code>.</p>

		<P>For example, using <code>showkey -s</code> one sees that Microsoft keyboards
		use the scancode sequences (in hexadecimal) e0 5b (left Windows key),
		e0 5c (right Windows key), e0 5d (Menu key).
		Microsoft Internet keyboard also uses e0 6a (Back), e0 69 (Forward),
		e0 68 (Stop), e0 6c (Mail), e0 65 (Search), e0 66 (Favorites),
		e0 32 (Web/Home), e0 6b (My Computer), e0 21 (Calculator), e0 5f (Sleep).
		Use <code>dumpkeys</code> to see what keycodes are still unused.
		Typically values like 89-95 and 112-118 and 120-127 are free.
		Now
		<pre>
        % setkeycodes e05b 125
        % setkeycodes e05c 126
        % setkeycodes e05d 127
</pre>

		assigns keycodes to these scancode sequences, and
		<pre>
        % loadkeys
        keycode 125 = Decr_Console
        keycode 126 = Incr_Console
        keycode 127 = KeyboardSignal
        %
</pre>

		would make these Windows keys go to the previous or next virtual console,
		and let the Menu key create a fresh virtual console (in case you have
		something like <code>spawn_console</code> running).</p>

		<div class="page-header">
			<h3><a name="ss14.1">Funkeys</a></h3>
		</div>

		<P>Many modern keyboards have buttons or keys with labels like
		"Vol Up", "Eject" etc. that suggest actions rather than strings.
		Of course one can bind shell commands to them, but then they'll
		work only when you are at a shell prompt.
		Rick van Rein wrote a package funkey consisting of a kernel patch
		and a daemon. The kernel patch creates a new character device,
		and adds a new key type to indicate which keystrokes should be
		sent to this new character device. A daemon can now listen to
		the character device, somewhat like <code>gpm</code> listens to the
		mouse device, and perform the actions indicated in its config file.
		See <a href="http://rick.vanrein.org/linux/funkey">rick.vanrein.org/linux/funkey</a>.</p>

		<hr/>
		<nav>
			<ul class="pagination">
				<li class="page-item"><a class="page-link" href="kbd-13.html">Previous</a></li>
				<li class="page-item"><a class="page-link" href="kbd-15.html">Next</a></li>
			</ul>
		</nav>
	</body>
</html>
