<!DOCTYPE html>		
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
		<title>The Linux keyboard and console HOWTO: Console switching</title>
	</head>
	<body class="container">
		<nav>
			<ul class="pager">
				<li class="previous"><a href="kbd-6.html">Previous</a></li>
				<li class="next"><a href="kbd-8.html">Next</a></li>
			</ul>
		</nav>

		<div class="page-header">
			<h2><a name="s7">Console switching</a></h2>
		</div>

		<p>By default, console switching is done using Alt-Fn or Ctrl-Alt-Fn.
		Under <code>X</code> (or recent versions of <code>dosemu</code>), only Ctrl-Alt-Fn works.
		Many keymaps will allow cyclic walks through all allocated consoles
		using Alt-RightArrow and Alt-LeftArrow.</p>

		<p>XFree86 1.3 does not know that Alt is down when you switch to the X
		window. Thus, you cannot switch immediately to some other VT again
		but have to release Alt first.
		In the other direction this should work: the kernel always keeps
		track of the up/down status of all keys. (As far as possible: on some
		keyboards some keys do not emit a scancode when pressed (e.g.: the PFn
		keys of a FOCUS 9000) or released (e.g.: the Pause key of many keyboards).)</p>

		<p>XFree86 1.3 saves the fonts loaded in the character ROMs when started,
		and restores it on a console switch. Thus, the result of <code>setfont</code> on
		a VT is wiped out when you go to X and back.
		Using <code>setfont</code> under X will lead to funny results.</p>

		<p>One can change VT under program control using the <code>chvt</code> command.</p>

		<div class="page-header">
			<h3><a name="ss7.1">Changing the number of Virtual Consoles</a></h3>
		</div>

		<p>This question still comes up from time to time, but the answer is:
		you already have enough of them.
		Since kernel version 1.1.54, there are between 1 and 63 virtual
		consoles. A new one is created as soon as it is opened. It is
		removed by the utility <code>deallocvt</code> (but it can be removed only when
		no processes are associated to it anymore, and no text on it has been
		selected by programs like <code>selection</code> or <code>gpm</code>).

		<p>For older kernels, change the line
		<pre>
        #define NR_CONSOLES     8
</pre>

		in <code>include/linux/tty.h</code> (don't increase this number beyond 63),
		and recompile the kernel.</p>

		<p>If they do not exist yet, create the tty devices with <code>MAKEDEV</code>
		or <code>mknod tty</code>N <code>c 4</code> N where N denotes the tty number. For example,
		<pre>
        for i in 9 10 11 12; do mknod /dev/tty$i c 4 $i; done
</pre>

		or, better (since it also takes care of owner and permissions),
		<pre>
        for i in 9 10 11 12; do /dev/MAKEDEV tty$i; done
</pre>
		</p>

		<p>If you want the new VCs to run <code>getty</code>, add lines in <code>/etc/inittab</code>.
		(But it is much better to have only two <code>getty</code>'s running,
		and to create more consoles dynamically as the need arises.
		That way you'll have more memory when you don't use all these consoles,
		and also more consoles, in case you really need them.
		Edit <code>/etc/inittab</code> and comment out all <code>getty</code>'s except
		for the first two.)</p>

		<p>When the consoles are allocated dynamically, it is usually easiest
		to have only one or two running <code>getty</code>. More are opened by
		<code>open -l -s bash</code>. Unused consoles (without associated processes)
		are deallocated using <code>deallocvt</code> (formerly <code>disalloc</code>).
		But, you say, I am involved in activities when I suddenly need more
		consoles, and do not have a bash prompt available to give the <code>open</code>
		command.
		Fortunately it is possible to create a new console upon a single
		keystroke, regardless of what is happening at the current console.</p>

		<p>If you have <code>spawn_login</code> from <code>kbd-1.04.tar.gz</code> and you put
		<pre>
        loadkeys &lt;&lt; EOF
        alt keycode 103 = Spawn_Console
        EOF
        spawn_login &amp;
</pre>

		in <code>/etc/rc.local</code>, then typing Alt-UpArrow will create a fresh VC
		running <code>login</code> (and switch to it). With <code>spawn_console &amp;</code> instead of
		<code>spawn_login &amp;</code> you'll have bash running there.
		See also <code>open-1.4.tgz</code> and <code>dynamic-vc-1.1.tar.gz</code>.</p>

		<p>What action should be taken upon this Spawn_Console keypress
		can also be set in <code>/etc/inittab</code> under <code>kbrequest</code>,
		if you have a recent <code>init</code>. See inittab(5).</p>

		<p>(This action can be something entirely different - I just called
		the key Spawn_Console because that is what I used it for.
		When used for other purposes it is less confusing to use
		its synonym KeyboardSignal.
		For example, some people like to put the lines
		<pre>
        kb::kbrequest:/sbin/shutdown -h now
</pre>

		in <code>/etc/inittab</code>, and
		<pre>
        control alt keycode 79 = KeyboardSignal
        control alt keycode 107 = KeyboardSignal
</pre>

		in their keymap. Now Ctrl-Alt-End will do a system shutdown.)</p>

		<p>You can only login as "root" on terminals listed in <code>/etc/securetty</code>.
		There exist programs that read terminal settings from files
		<code>/etc/ttys</code> and <code>/etc/ttytype</code>. If you have such
		files, and create additional consoles, then it might be a good idea
		to also add entries for them in these files.</p>

		<hr/>
		<nav>
			<ul class="pager">
				<li class="previous"><a href="kbd-6.html">Previous</a></li>
				<li class="next"><a href="kbd-8.html">Next</a></li>
			</ul>
		</nav>
	</body>
</html>
